package fetcher

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"strings"
	"time"

	"github.com/gocarina/gocsv"
	"github.com/inconshreveable/log15"
	"github.com/mozqnet/go-exploitdb/models"
	"github.com/mozqnet/go-exploitdb/util"
	"github.com/pkg/errors"
	"golang.org/x/net/html/charset"
)

// FetchExploitDB :
func FetchExploitDB() (exploits []models.Exploit, err error) {
	var exploitCvesMap map[string][]string
	if exploitCvesMap, err = FetchExploitCvesMap(); err != nil {
		return nil, err
	}
	var exploitShellCodeMap map[string]*models.ShellCode
	if exploitShellCodeMap, err = FetchExploitShellCodeMap(); err != nil {
		return nil, err
	}
	var exploitPaperMap map[string]*models.Paper
	if exploitPaperMap, err = FetchExploitPaperMap(); err != nil {
		return nil, err
	}

	var exploitDocs []*models.Document
	if exploitDocs, err = FetchExploitDocuments(); err != nil {
		return nil, err
	}

	for _, doc := range exploitDocs {
		cveIDs, ok := exploitCvesMap[doc.ExploitDBID]
		if ok {
			for _, cveID := range cveIDs {
				exploit := models.Exploit{
					ExploitDBID:  doc.ExploitDBID,
					ExploitDBURL: "https://www.exploit-db.com/exploits/" + doc.ExploitDBID,
					CveID:        cveID,
					Document:     doc,
					ShellCode:    exploitShellCodeMap[doc.ExploitDBID],
					Paper:        exploitPaperMap[doc.ExploitDBID],
				}
				exploits = append(exploits, exploit)
			}
		} else {
			// No CveID
			exploit := models.Exploit{
				ExploitDBID:  doc.ExploitDBID,
				ExploitDBURL: "https://www.exploit-db.com/exploits/" + doc.ExploitDBID,
				Document:     doc,
				ShellCode:    exploitShellCodeMap[doc.ExploitDBID],
				Paper:        exploitPaperMap[doc.ExploitDBID],
			}
			exploits = append(exploits, exploit)
		}
	}
	return exploits, nil
}

// FetchExploitCvesMap :
func FetchExploitCvesMap() (exploitCveMap map[string][]string, err error) {
	exploitCveMap = map[string][]string{}
	for year := 1999; year <= time.Now().Year(); year++ {
		url := fmt.Sprintf("http://cve.mitre.org/data/downloads/allitems-cvrf-year-%d.xml", year)
		log15.Info("Fetching", "URL", url)
		cveXML, err := util.FetchURL(url)
		if err != nil {
			return nil,
				errors.Wrapf(err, "Failed to fetch cve data from Microsoft. targetURL: %s", url)
		}

		var mitreCve models.MitreXML
		// https://stackoverflow.com/questions/6002619/unmarshal-an-iso-8859-1-xml-input-in-go
		decoder := xml.NewDecoder(bytes.NewReader(cveXML))
		decoder.CharsetReader = charset.NewReaderLabel
		if err = decoder.Decode(&mitreCve); err != nil {
			return nil, errors.Wrap(err, "Failed to Unmarshal XML")
		}
		for _, vuln := range mitreCve.Vulnerability {
			for _, ref := range vuln.References {
				desc := strings.Split(ref.Description, ":")
				if len(desc) != 2 {
					continue
				}
				refType, exploitID := desc[0], desc[1]
				if refType != "EXPLOIT-DB" {
					continue
				}
				exploitCveMap[exploitID] = append(exploitCveMap[exploitID], vuln.CVE)
			}
		}
	}
	return exploitCveMap, nil
}

// FetchExploitShellCodeMap :
func FetchExploitShellCodeMap() (exploitShellCodeMap map[string]*models.ShellCode, err error) {
	exploitShellCodeMap = map[string]*models.ShellCode{}
	url := "https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_shellcodes.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	shellCodes := []*models.ShellCode{}
	if err := gocsv.UnmarshalBytes(cveCsv, &shellCodes); err != nil {
		return nil, err
	}

	for _, shellCode := range shellCodes {
		shellCode.ShellCodeURL = "https://github.com/offensive-security/exploitdb/" + shellCode.ShellCodeURL
		exploitShellCodeMap[shellCode.ExploitDBID] = shellCode
	}
	return exploitShellCodeMap, nil
}

// FetchExploitPaperMap :
func FetchExploitPaperMap() (exploitPaperMap map[string]*models.Paper, err error) {
	exploitPaperMap = map[string]*models.Paper{}
	url := "https://raw.githubusercontent.com/offensive-security/exploitdb-papers/master/files_papers.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	papers := []*models.Paper{}
	if err := gocsv.UnmarshalBytes(cveCsv, &papers); err != nil {
		return nil, err
	}

	for _, paper := range papers {
		paper.PaperURL = "https://github.com/offensive-security/exploitdb-papers/" + paper.PaperURL
		exploitPaperMap[paper.ExploitDBID] = paper
	}
	return exploitPaperMap, nil
}

// FetchExploitDocuments :
func FetchExploitDocuments() (docs []*models.Document, err error) {
	url := "https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_exploits.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	docs = []*models.Document{}
	if err := gocsv.UnmarshalBytes(cveCsv, &docs); err != nil {
		return nil, err
	}

	for _, doc := range docs {
		doc.DocumentURL = "https://github.com/offensive-security/exploitdb/" + doc.DocumentURL
	}
	return docs, nil
}
